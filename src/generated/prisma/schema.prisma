// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// Available LLM models catalog
model AvailableModel {
  id            String   @id @default(cuid()) // e.g., "openai/gpt-4o"
  name          String // e.g., "GPT-4o"
  description   String? // e.g., "GPT-4o is OpenAI's flagship model..."
  contextLength Int?     @map("context_length")
  pricing       Json? // { prompt: string, completion: string, image?: string, request?: string }
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  @@map("available_models")
}

// Users table for Firebase authentication
model User {
  id        String      @id // Firebase UID
  email     String
  name      String?
  photoURL  String?     @map("photo_url")
  createdAt DateTime    @map("created_at")
  updatedAt DateTime    @updatedAt @map("updated_at")
  projects  Project[]
  wallet    UserWallet?

  @@map("users")
}

// Projects table
model Project {
  id            String         @id @default(cuid())
  userId        String         @map("user_id")
  name          String
  createdAt     DateTime       @map("created_at")
  updatedAt     DateTime       @updatedAt @map("updated_at")
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  projectMemory ProjectMemory?
  threads       Thread[]
  messages      Message[]

  @@map("projects")
}

// Project memory for context preservation
model ProjectMemory {
  id            String   @id @default(cuid())
  projectId     String   @unique @map("project_id")
  summary       String   @default("")
  facts         Json     @default("[]") // string[]
  decisions     Json     @default("[]") // { decision: string, reasoning: string, date: string }[]
  openQuestions Json     @default("[]") @map("open_questions") // string[]
  updatedAt     DateTime @updatedAt @map("updated_at")
  project       Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@map("project_memory")
}

// Threads (conversations) within a project
model Thread {
  id        String    @id @default(cuid())
  projectId String    @map("project_id")
  title     String
  mode      String    @default("multiask") // "multiask" or "critique"
  createdAt DateTime  @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  project   Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  messages  Message[]

  @@map("threads")
}

// Messages within threads
model Message {
  id         String   @id @default(cuid())
  threadId   String   @map("thread_id")
  projectId  String   @map("project_id")
  role       String // "user", "assistant", "system", "verdict", "critique", "review"
  content    String
  modelUsed  String?  @map("model_used")
  turnNumber Int      @default(1) @map("turn_number") // Groups messages by conversation turn
  metadata   Json? // Record<string, unknown>
  createdAt  DateTime @map("created_at")
  thread     Thread   @relation(fields: [threadId], references: [id], onDelete: Cascade)
  project    Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@map("messages")
}

// User wallet for credits management
model UserWallet {
  userId               String                @id @map("user_id")
  balanceMicrocredits  BigInt                @default(1500000000) @map("balance_microcredits")
  subscriptionStatus   String                @default("free") @map("subscription_status")
  currentPeriodEnd     DateTime?             @map("current_period_end") @db.Timestamptz
  capMicrocredits      BigInt                @default(40000000000) @map("cap_microcredits")
  createdAt            DateTime              @default(now()) @map("created_at") @db.Timestamptz
  updatedAt            DateTime              @updatedAt @map("updated_at") @db.Timestamptz
  user                 User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  subscriptionPayments SubscriptionPayment[]
  creditUsage          CreditUsage[]

  @@index([subscriptionStatus])
  @@map("user_wallet")
}

// Subscription payments ledger (money-in)
model SubscriptionPayment {
  id                        String     @id @default(cuid())
  userId                    String     @map("user_id")
  paymentProvider           String     @map("payment_provider")
  paymentProviderId         String     @unique @map("payment_provider_id")
  amountPaidCents           Int        @map("amount_paid_cents")
  currency                  String     @default("USD")
  grantMicrocredits         BigInt     @map("grant_microcredits")
  balanceBeforeMicrocredits BigInt     @map("balance_before_microcredits")
  balanceAfterMicrocredits  BigInt     @map("balance_after_microcredits")
  createdAt                 DateTime   @default(now()) @map("created_at") @db.Timestamptz
  wallet                    UserWallet @relation(fields: [userId], references: [userId], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
  @@map("subscription_payments")
}

// Credit usage ledger (money-out)
model CreditUsage {
  id                        String     @id @default(cuid())
  userId                    String     @map("user_id")
  requestId                 String     @unique @map("request_id")
  openrouterGenerationId    String?    @map("openrouter_generation_id")
  modelUsed                 String?    @map("model_used")
  activityType              String     @map("activity_type")
  costMicrousd              BigInt     @map("cost_microusd")
  debitMicrocredits         BigInt     @map("debit_microcredits")
  tokenUsage                Json?      @map("token_usage")
  balanceBeforeMicrocredits BigInt     @map("balance_before_microcredits")
  balanceAfterMicrocredits  BigInt     @map("balance_after_microcredits")
  createdAt                 DateTime   @default(now()) @map("created_at") @db.Timestamptz
  wallet                    UserWallet @relation(fields: [userId], references: [userId], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
  @@map("credit_usage")
}
